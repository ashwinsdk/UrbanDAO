// SPDX-License-Identifier: MIT
/**
 * UrbanDAO Role Management Script
 * 
 * This script checks, assigns, and verifies roles for the UrbanDAO system.
 * It uses the existing deployed contracts and follows the role hierarchy:
 * - Owner assigns AdminGovt
 * - AdminGovt assigns AdminHead
 * - AdminHead assigns other roles (Validator, TaxCollector, ProjectManager)
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');
const { ethers } = require('ethers');

// Import contract artifacts
const UrbanCoreArtifact = require('../artifacts/contracts/UrbanCore.sol/UrbanCore.json');
const AccessRolesArtifact = require('../artifacts/contracts/AccessRoles.sol/AccessRoles.json');

// Load deployment addresses and role configuration
const DEPLOYED_ADDRESSES = require('../deployed/addresses.json');
const ROLES_CONFIG = require('../../docs/roles.json');

// Role constants - these match the constants in AccessRoles.sol
const ROLE_CONSTANTS = {
  OWNER_ROLE: ethers.keccak256(ethers.toUtf8Bytes("OWNER_ROLE")),
  ADMIN_GOVT_ROLE: ethers.keccak256(ethers.toUtf8Bytes("ADMIN_GOVT_ROLE")),
  ADMIN_HEAD_ROLE: ethers.keccak256(ethers.toUtf8Bytes("ADMIN_HEAD_ROLE")),
  PROJECT_MANAGER_ROLE: ethers.keccak256(ethers.toUtf8Bytes("PROJECT_MANAGER_ROLE")),
  TAX_COLLECTOR_ROLE: ethers.keccak256(ethers.toUtf8Bytes("TAX_COLLECTOR_ROLE")),
  VALIDATOR_ROLE: ethers.keccak256(ethers.toUtf8Bytes("VALIDATOR_ROLE")),
  CITIZEN_ROLE: ethers.keccak256(ethers.toUtf8Bytes("CITIZEN_ROLE")),
  TX_PAYER_ROLE: ethers.keccak256(ethers.toUtf8Bytes("TX_PAYER_ROLE"))
};

// Role hierarchy for assignment
const ROLE_HIERARCHY = [
  { role: 'OWNER_ROLE', assigner: null }, // Owner is already assigned during deployment
  { role: 'ADMIN_GOVT_ROLE', assigner: 'OWNER_ROLE' },
  { role: 'ADMIN_HEAD_ROLE', assigner: 'ADMIN_GOVT_ROLE' },
  { role: 'PROJECT_MANAGER_ROLE', assigner: 'ADMIN_HEAD_ROLE' },
  { role: 'TAX_COLLECTOR_ROLE', assigner: 'ADMIN_HEAD_ROLE' },
  { role: 'VALIDATOR_ROLE', assigner: 'ADMIN_HEAD_ROLE' },
  { role: 'TX_PAYER_ROLE', assigner: 'OWNER_ROLE' }
  // CITIZEN_ROLE is not part of the initial setup, will be assigned by validators later
];

// Provider and wallet setup
async function setupProvider() {
  let provider;
  let networkName;
  
  if (process.env.SEPOLIA_RPC_URL) {
    provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);
    networkName = 'sepolia';
  } else {
    // Default to local development network
    provider = new ethers.JsonRpcProvider('http://localhost:8545');
    networkName = 'localhost';
  }
  
  console.log(`Connected to network: ${networkName}`);
  return provider;
}

// Get a signer with the given private key
async function getSigner(provider, privateKey) {
  try {
    const wallet = new ethers.Wallet(privateKey, provider);
    console.log(`Using wallet with address: ${wallet.address}`);
    return wallet;
  } catch (error) {
    console.error(`Error creating wallet: ${error.message}`);
    throw error;
  }
}

// Connect to the UrbanCore contract
async function getUrbanCoreContract(signer) {
  const urbanCoreAddress = DEPLOYED_ADDRESSES.contracts.UrbanCore;
  console.log(`UrbanCore address: ${urbanCoreAddress}`);
  
  const urbanCore = new ethers.Contract(
    urbanCoreAddress,
    UrbanCoreArtifact.abi,
    signer
  );
  
  return urbanCore;
}

// Check if an address has a role
async function hasRole(urbanCore, role, address) {
  try {
    return await urbanCore.hasRole(ROLE_CONSTANTS[role], address);
  } catch (error) {
    console.error(`Error checking role ${role} for ${address}: ${error.message}`);
    return false;
  }
}

// Assign a role to an address if not already assigned
async function assignRoleIfNeeded(urbanCore, signer, role, targetAddress) {
  try {
    const roleHash = ROLE_CONSTANTS[role];
    const hasRoleAlready = await urbanCore.hasRole(roleHash, targetAddress);
    
    if (hasRoleAlready) {
      console.log(`✓ Address ${targetAddress} already has role ${role}`);
      return true;
    }
    
    console.log(`Assigning ${role} to ${targetAddress}...`);
    
    const grantRoleFn = urbanCore.interface.getFunction('grantRole');
    const data = urbanCore.interface.encodeFunctionData(grantRoleFn, [roleHash, targetAddress]);
    
    const tx = await signer.sendTransaction({
      to: urbanCore.address,
      data: data,
      gasLimit: 300000  // Set appropriate gas limit
    });
    
    console.log(`Transaction hash: ${tx.hash}`);
    
    // Wait for transaction confirmation
    const receipt = await tx.wait();
    console.log(`Transaction confirmed in block ${receipt.blockNumber}`);
    console.log(`✓ Successfully assigned ${role} to ${targetAddress}`);
    
    return true;
  } catch (error) {
    console.error(`Error assigning role ${role} to ${targetAddress}: ${error.message}`);
    return false;
  }
}

// Main function to manage roles
async function manageRoles() {
  try {
    // Setup provider
    const provider = await setupProvider();
    
    // Initialize results tracking
    const results = {
      success: [],
      failed: [],
      alreadyAssigned: []
    };
    
    // Process roles in order of hierarchy
    for (const roleConfig of ROLE_HIERARCHY) {
      const { role, assigner } = roleConfig;
      const targetAddress = ROLES_CONFIG.roles[role].address;
      
      console.log(`\n======= Processing ${role} =======`);
      console.log(`Target address: ${targetAddress}`);
      
      // Skip OWNER_ROLE as it should be set during deployment
      if (role === 'OWNER_ROLE') {
        console.log('Owner role should be set during deployment, skipping assignment');
        
        // However, we still verify the owner has the role
        const ownerSigner = await getSigner(provider, process.env.OWNER_PRIVATE_KEY || '0x' + ROLES_CONFIG.roles.OWNER_ROLE.privateKey);
        const urbanCore = await getUrbanCoreContract(ownerSigner);
        
        const isOwner = await hasRole(urbanCore, 'OWNER_ROLE', targetAddress);
        if (isOwner) {
          console.log(`✓ Verified ${targetAddress} has OWNER_ROLE`);
          results.alreadyAssigned.push({ role, address: targetAddress });
        } else {
          console.error(`✗ ERROR: ${targetAddress} does not have OWNER_ROLE but should`);
          results.failed.push({ role, address: targetAddress });
        }
        continue;
      }
      
      // Get the appropriate signer for this role's assigner
      let assignerPrivateKey;
      if (process.env[`${assigner}_PRIVATE_KEY`]) {
        assignerPrivateKey = process.env[`${assigner}_PRIVATE_KEY`];
      } else {
        // Use the private key from accounts.txt (stored in memory)
        assignerPrivateKey = '0x' + {
          'OWNER_ROLE': '07446a2aab1e7449202eaad0a2fc66089511a091218acc4414288b80dd7e18b1',
          'ADMIN_GOVT_ROLE': '07446a2aab1e7449202eaad0a2fc66089511a091218acc4414288b80dd7e18b1', // Same as owner
          'ADMIN_HEAD_ROLE': '157703d904153e724d8126002483b5a2cb389b641ebb35637870eec2f0b40b12',
          'PROJECT_MANAGER_ROLE': 'b3ff9baa154df197ee7cb690dd0a03ecba9398e4dce6f543562fbe9c23692fbf',
          'TAX_COLLECTOR_ROLE': '41d1689496949691ee014587bd26000448c4512cdc42929f11ea24106806c089',
          'VALIDATOR_ROLE': '2465f4b6c792446f463b37145d70aa2eb69c16f697e9c790e72b4ade1343eec2',
          'TX_PAYER_ROLE': 'e2e7813cd14e8e7765b848d4eb48bf8257e1367ba4d896a867b9e1224a0b07fe'
        }[assigner];
      }
      
      const assignerSigner = await getSigner(provider, assignerPrivateKey);
      const urbanCore = await getUrbanCoreContract(assignerSigner);
      
      // Check if the address already has the role
      const hasRoleAlready = await hasRole(urbanCore, role, targetAddress);
      
      if (hasRoleAlready) {
        console.log(`✓ Address ${targetAddress} already has role ${role}`);
        results.alreadyAssigned.push({ role, address: targetAddress });
      } else {
        // Assign role if not already assigned
        const success = await assignRoleIfNeeded(
          urbanCore,
          assignerSigner,
          role,
          targetAddress
        );
        
        if (success) {
          results.success.push({ role, address: targetAddress });
        } else {
          results.failed.push({ role, address: targetAddress });
        }
      }
    }
    
    // Print summary of results
    console.log('\n======= Role Management Summary =======');
    console.log(`Roles already assigned: ${results.alreadyAssigned.length}`);
    console.log(`Roles successfully assigned: ${results.success.length}`);
    console.log(`Failed role assignments: ${results.failed.length}`);
    
    if (results.failed.length > 0) {
      console.error('\nFailed assignments:');
      results.failed.forEach(item => {
        console.error(`- ${item.role} -> ${item.address}`);
      });
    }
    
    // Update the roles.json file with verification status
    updateRolesJsonWithVerification(results);
    
    return results;
  } catch (error) {
    console.error(`Error in manageRoles: ${error.message}`);
    console.error(error);
    return { success: [], failed: [], alreadyAssigned: [] };
  }
}

// Update roles.json with verification status
function updateRolesJsonWithVerification(results) {
  const rolesJsonPath = path.join(__dirname, '../../docs/roles.json');
  const rolesData = require(rolesJsonPath);
  
  // Add verification timestamp
  rolesData.lastVerified = new Date().toISOString();
  
  // Update status for each role
  Object.keys(rolesData.roles).forEach(role => {
    const address = rolesData.roles[role].address;
    
    if (results.success.find(r => r.role === role && r.address === address)) {
      rolesData.roles[role].status = 'assigned';
    } else if (results.alreadyAssigned.find(r => r.role === role && r.address === address)) {
      rolesData.roles[role].status = 'verified';
    } else if (results.failed.find(r => r.role === role && r.address === address)) {
      rolesData.roles[role].status = 'failed';
    } else {
      rolesData.roles[role].status = 'unknown';
    }
  });
  
  // Write updated data back to file
  fs.writeFileSync(rolesJsonPath, JSON.stringify(rolesData, null, 2));
  console.log(`Updated roles.json with verification status at ${rolesJsonPath}`);
}

// Run the script if called directly
if (require.main === module) {
  manageRoles()
    .then(() => process.exit(0))
    .catch(error => {
      console.error(error);
      process.exit(1);
    });
}

module.exports = {
  manageRoles,
  hasRole,
  assignRoleIfNeeded
};
